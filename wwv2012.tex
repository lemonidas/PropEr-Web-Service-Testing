\documentclass[submission,copyright,a4]{eptcs}
\providecommand{\event}{WWV 2012}
\usepackage{breakurl}

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

\usepackage{graphicx} % support the \includegraphics command and options

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{listings}
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

\lstset{language=erlang,
        basicstyle=\footnotesize\ttfamily,
        columns=flexible,
        %tabsize=2,
        %numberbychapter=false,
        captionpos=b,
        %commentstyle=,
        %basewidth=0.51em,
        frame=single,
        %framesep=2pt,
        %frameround=tttt,
        breaklines=true,
        breakatwhitespace=true}

\title{Automatic WSDL-guided Property-based Testing of Web Services}
\author{Leonidas Lampropoulos \and Konstantinos Sagonas}
\def\titlerunning{Automatic WSDL-guided Property-based Testing of Web Services}
\def\authorrunning{L. Lampropoulos and K. Sagonas}

\begin{document}
\maketitle

\begin{abstract}
 This will be the greatest paper ever written...
\end{abstract}

\section{Introduction}

We describe an extension of PropEr to accomodate WSDL-guided property-based testing of web services. This extension receives the URL of a Web Service (or more accurately the url of the Web Service's WSDL specification), parses the specification and creates an output file containing generators and properties for all the SOAP Web Service operations. The output file can be automatically compiled and used for response testing of Web Services with random, yet structurally valid testcases. In addition, the automatically created PropEr generators and properties can be easily modified, allowing the user to write properties the Web Service should satisfy, utilizing the full power of Erlang and PropEr.

\section{System Architecture}

Picture Here

The picture above shows the architecture of our testing framework. Firstly, we get the WSDL specification of the Web Service. This specification is then fed into two different erlang tools, Yaws and Xmerl, which will be briefly described later on in this section. Using xmerl, we extract all the type information associated with the WSDL specification, while using yaws we extract all supported (SOAP) operations. The extracted information is then used to create a testing file (erlang code) that contains PropEr generators and properties ready for use. Then, the user can (optionally) modify the testing file to add his own properties or refine the generators. The testing file is then given as input to PropEr, which generates random testcases, invokes the Web Service (using Yaws as a SOAP wrapper) and then analyzes the result.

%To use the extension required are an Erlang distribution (with xmerl), Proper and Yaws.
%To run some of the examples below, Eclipse and Tomcat have been used, but any means of creating a Web Service should be an option.

\subsection{WSDL}

WSDL is the leading specification for web services in XML format, describing the web service in full: operations, input and output message types, locations, bindings, port types etc. 

Every WSDL specification contains (or references) an XSD schema inside, describing the types of the messages needed to invoke the Web Service. The types of these messages are divided in two large categories: simple and complex types. Simple types can be either primitive datatypes, such as floats, ints, strings, etc., aggregates of the above, such as lists and unions, or restricted versions of them, like enumerations or range constraints. Complex types on the other hand are derived (extented or restricted) based on other types, which in turn are either simple or complex. Usually, complex types are created by forming element aggregates - sequences or choices. 

In addition to types, a WSDL specification also describes the operations the Web Service provides, along with information linking the input and output messages of an operation with types defined in the XSD Schema. 

\subsection{PropEr}

\subsection{Yaws}

Yaws is the most widely used Erlang HTTP webserver. Yaws uses an XML parser called Erlsom to handle its soap message encoding/decoding, a parser module faster and more user friendly than the xmerl module of the Erlang distribution, imposing however a few additional limitations. In our framework, Yaws is used at two different times: in the beginning, in order to extract all the supported SOAP operations from the WSDL specification, and during the actual testing phase, as an intermediary between PropEr and the Web Service, wrapping the data generated by PropEr in valid SOAP structure, invoking a Web Service operation with the formed SOAP message, retrieving the result and returning it in the form of an erlang tuple to PropEr for further analysis.

\subsection{xmerl}

Xmerl is an XML parser, included in the erlang/OTP distribution. It transforms any XML to a (rather verbose) erlang structure containing all the information contained in the original XML document. In our framework, xmerl is used to parse the XSD Schema of the WSDL specification, in order to extract the typing information nedded to create PropEr generators.

\section{Automatic Creation of Generators and Properties}

The main idea behind the extension is to use PropEr to do property based testing on web services. This extension helps the user by creating generators, sample properties and call functions so that the user focuses on the important task - writing the property. 

\subsection{Automatic Creation Generators from WSDL Types}

The most important part of our tool is the automatic creation of PropEr generators from the types described in the WSDL specification. To that end, we introduce an intermediate erlang representation of the WSDL types; a representation that can be directly mapped to PropEr generators, while at the same time is easier to work with and handle all constraining facets of the XSD Schema. The following XSD Schema is an example of a type specification of a Web Service which we will use to show how the generators are created.

%The most important part of the extension is automatically creating PropEr generators for each input message type of the operations supported. To that end, we parse the XSD schema of the WSDL specification using the xmerl module and create the most generic generators for the types described, in the format Yaws and Erlsom expect their arguments. While parsing the XSD schema, we use a small tuple format as an intermediate representation of the types of the Web Service, so that the resulting generators can be directly mapped from these tuples while being able to give the generators unique and descriptive names. These tuples are never encountered by the user, yet are extremely helpful in holding all the necessary information (and only that) to create the PropEr generators and overcome some important limitations that would otherwise be imposed by Erlsom. (? Thelei kati allo edw prin apo to paradeigma ?)

\begin{lstlisting}
  <complexType name="ProductType">
    <sequence>
      <element maxOccurs="1" minOccurs="1" name="name" type="xsd:string"/>
      <element maxOccurs="1" minOccurs="1" name="price" type="xsd:positiveInteger"/>
      <element maxOccurs="1" minOccurs="1" name="shipInfo" type="impl:ShipInfo"/>
    </sequence>
  </complexType>
  <simpleType name="PaymentType">
    <restriction base="xsd:string">
      <enumeration value="visa"/>
      <enumeration value="paypal"/>
      <enumeration value="deposit"/>
    </restriction>
  </simpleType>
  <complexType name="ShipInfo">
    <sequence>
      <element maxOccurs="1" minOccurs="1" name="paymentInfo" type="impl:PaymentType"/>
      <element maxOccurs="1" minOccurs="1" name="address" type="xsd:string"/>
    </sequence>
  </complexType>
  <element name="Order">
    <complexType>
      <sequence>
        <element maxOccurs="unbounded" minOccurs="1" name="products" type="impl:ProductType"/>
      </sequence>
    </complexType>
  </element>
  <element name="Product" type="impl:ProductType"/>
\end{lstlisting}

% Na mpei edw kapoia perigrafi tou parapanw sximatos i den xreiazetai?

Suppose we want to create a generator for an operation "placeOrder" of a Web Service that takes as an argument a single element "Order". In the front end of the implementation, we use the information provided by the xmerl module after parsing the schema to go through all elements and their types recursively, passing through all the nodes of the XSD schema in a DFS style. In every such node, we create a tuple that contains both name and type information for the node and all its succesors. 

Simple types yield tuples that contain only type information, along with an atom to facilitate compatibility with Erlsom and Yaws. In our example, we encounter three different simple types. Two of them, namely xsd:string and xsd:positiveInteger represent primitive datatypes of the WSDL specification, where as "tns:PaymentType" is a user defined simple type - a restriction upon the string type. The tuples associated with these types in our tool are:

\begin{lstlisting}
xsd:positiveInteger : {erlsom_string,integer,{1,inf}}
\end{lstlisting}

The positiveInteger primitive datatype is mapped by default to the above tuple. The first argument 'erlsom\_string' states that for compatibility with Yaws it must be converted to String before wrapped in valid SOAP structure, the second argument that the base PropEr generator is 'integer()' and the last denotes the range (minimum and maximum value of the generated value) is between 1 and infinity. 

\begin{lstlisting}
xsd:string : {list,{{range,0,inf},{erlsom_int,integer,{32,127}}}}
\end{lstlisting}

This simple type shows how strings are mapped to intermediate tuples. The first argument shows that the entire tuples representes a list and the second argument specifies the length of the list (in this case it is arbitrary) and the inner type (its intermediate represantation) of the list (in this case a character - since strings in erlang are lists of numbers, the generator creates such lists with integers in the range 32 - 127, printable characters in the ascii table).

\begin{lstlisting}
tns:PaymentType: {elements,["visa","paypal","deposit"]}
\end{lstlisting}

The final simple type is a user defined restriction upon the basic string datatype, defining an enumeration of the acceptable values. As a result the only acceptable values are "visa", "paypal" or "deposit" and the intermediate tuple denotes just that.

Elements yield tuples that contain type and naming information. The naming information contains the name of the element (if it exists) as well as namespace information of the XSD Schema. For example the "price" element:

\begin{lstlisting}
<element maxOccurs="1" minOccurs="1" name="price" type="xsd:positiveInteger"/>
\end{lstlisting}

is represented with the tuple:

\begin{lstlisting}
{{price,['ProductType'],'http://bar'}, {erlsom_string,integer,{1,inf}}}
\end{lstlisting}

Finally complex types usually define aggregates of simple types. In our example, we encounter three complex types, all of which combine child elements with a "sequence" combinator. For example, the "ShipInfo" complex type is represented as:

\begin{lstlisting}

{{'ShipInfo',[],'http://bar'},
  {tuple,
    [{{paymentInfo,['ShipInfo'],'http://bar'},
      {{'PaymentType',[],'http://bar'},
       {elements,["visa","paypal","deposit"]}}},
     {{address,['ShipInfo'],'http://bar'},
      {list, {{range,0,inf}, {erlsom_int,integer,{32,127}}}}}]}}
\end{lstlisting}

This shows that besides the name information, the intermediate representation consists of a "tuple" atom - indicative of the "sequence" combinator and a list of the child intermediate tuples. In this case, since the minOccurs and maxOccurs attributes for the child elements are both equal to 1, we include the child generator as is. In case these attributes implied a collection (eg unbounded), we would need to wrap the inner generators in a list intermediate tuple.

% Back end now

The mapping of the intermediate tuples to PropEr generators is pretty straightforward by construction. Special care is only needed to ensure names for all generators are unique. To that end we use the full path up to the current node as prefix, leading to rather long but descriptive and unique names. The generators produced for the previous example by our tool are:

\begin{lstlisting}
generate_Order_1_products_ProductType_name() -> 
  list(integer(32,127)).

generate_Order_1_products_ProductType_price() ->  
  ?LET(Gen, integer(1,inf), integer_to_list(Gen)).

generate_Order_1_products_ProductType_shipInfo_ShipInfo_paymentInfo_PaymentType() -> 
  elements(["visa","paypal","deposit"]).

generate_Order_1_products_ProductType_shipInfo_ShipInfo_address() -> 
  list(integer(32,127)).

generate_Order_1_products_ProductType_shipInfo_ShipInfo() -> 
  ?LET(
    {Pr_Order_1_products_ProductType_shipInfo_ShipInfo_paymentInfo_PaymentType,
     Pr_Order_1_products_ProductType_shipInfo_ShipInfo_address},
    {generate_Order_1_products_ProductType_shipInfo_ShipInfo_paymentInfo_PaymentType(),
     generate_Order_1_products_ProductType_shipInfo_ShipInfo_address()},
    [Pr_Order_1_products_ProductType_shipInfo_ShipInfo_paymentInfo_PaymentType,
     Pr_Order_1_products_ProductType_shipInfo_ShipInfo_address]
  ).

generate_Order_1_products_ProductType() -> 
  ?LET(
    {Pr_Order_1_products_ProductType_name, 
     Pr_Order_1_products_ProductType_price, 
     Pr_Order_1_products_ProductType_shipInfo_ShipInfo},
    {generate_Order_1_products_ProductType_name(), 
     generate_Order_1_products_ProductType_price(), 
     generate_Order_1_products_ProductType_shipInfo_ShipInfo()},
    [Pr_Order_1_products_ProductType_name, 
     Pr_Order_1_products_ProductType_price, 
     Pr_Order_1_products_ProductType_shipInfo_ShipInfo] 
  ).

generate_Order_1_products() -> 
  ?LET(
    Len, 
    range(1,inf), 
    vector(Len, generate_Order_1_products_ProductType())
  ).

generate_Order_1() -> 
  ?LET(
    {Pr_Order_1_products},
    {generate_Order_1_products()},
    [Pr_Order_1_products]
 ).
\end{lstlisting}

The above code reveals the generation method. Simple types are mapped almost directly like the "PaymentType", with special care taken if needed to add a wrapper that converts the generated data to string if that is required by Yaws. Complex types on the other hand, need to be represented as lists for Yaws to accept them, and we use ?LET macros to that end. 
% Include the following or not?
PropEr would allow for simplicity to create less verbose versions of these generators with a little extra care for unique naming. For example the last generator could have been written as:

\begin{lstlisting}
generate_Order_1() ->
  [generate_Order_1_products()].
\end{lstlisting}

While in such a small example this would appear preferable, it actually makes things more difficult for the user, should he want to modify the generated test data or the generators. The importance of the ?LET macro can be seen in the following example: Suppose a Web Service has an operation that takes as input an element with an "ISBN" field amongst others (a semantically valid ISBN is a unique identifier for a book and consists of 10 single digits, the last of which is determined by the previous nine via a congruence). For such a Web Service, our tool would generate code of the following form:

\begin{lstlisting}
generate_opName() ->
  ?LET(
    {Pr_opName_ISBN,
     ...},
    {generate_opName_ISBN(),
     ...},
    [Pr_opName_ISBN,
     ...]
  ).
\end{lstlisting}

Where the generate\_opName\_ISBN() generator would create a 10-member list of single digit integers. With a small function that changes the first digit so that the ISBN congruence is satisfied (eg ISBNize()), one could rewrite the generator as:

\begin{lstlisting}
generate_opName() ->
  ?LET(
    {Pr_opName_ISBN,
     ...},
    {generate_opName_ISBN(),
     ...},
    [ISBNize(Pr_opName_ISBN),
     ...]
  ).
\end{lstlisting}

This is only possible with the use of the ?LET macro that allows you to modify and combine the generated data. 


\subsection{Automatic Creation of Properties from WSDL Operations}

The Proper extension also creates a function for each web service operation that invokes this operation with parameterized arguments and a small property to test that the Service always responds for random testcases without returning malformed XML or a Soap Fault for random (possibly corner) cases. For the Cooking service we described above there is a single soap operation supported, which is defined in the following WSDL specification exerpt:

\begin{lstlisting}
<wsdl:portType name="CookingUnitSoap">
  <wsdl:operation name="ChangeCookingUnit">
    <wsdl:input message="tns:ChangeCookingUnitSoapIn"/>
    <wsdl:output message="tns:ChangeCookingUnitSoapOut"/>
  </wsdl:operation>
</wsdl:portType>
\end{lstlisting}

The code created to invoke this operation and the respective property is the following:

\begin{lstlisting}
call_ChangeCookingUnit(Arguments) ->
  inets:start(),
  Wsdl = yaws_soap_lib:initModel(?WSDL_URL),
  yaws_soap_lib:call(Wsdl, "ChangeCookingUnit", Arguments).

call_ChangeCookingUnit(WSDL, Arguments) ->
  yaws_soap_lib:call(WSDL, "ChangeCookingUnit", Arguments).

prop_ChangeCookingUnit_responds() ->
  ?FORALL(Args, generate_ChangeCookingUnit_1(),
    begin
      Result = call_ChangeCookingUnit(Args),
      case Result of
	{ok, _Attribs, [#'soap:Fault'{}]}) -> false;
        {ok, _Attribs, _Result_record} -> true;
        _ -> false
      end
    end).
\end{lstlisting}

The first function simply calls the operation assuming nothing about the state of the connection (it tries to start a connection, (possibly re-)parses the WSDL specification and then invokes the operation, while the second function takes an already parsed WSDL specification structure and invokes the operation directly, which is far more efficient. Finally, the "responds" property simply creates the arguments using the previously created generator ("generate\_ChangeCookingUnit\_1()") and does a pattern matching on the resulting tuple after calling the web service. If this resulting tuple is a 'soap:Fault' record (or the resulting tuple is an\{error, Reason\} tuple) then the service failed to respond correctly (possibly raised an exception described in the record), otherwise we assume (conservatively) that the web service responded correctly.

\subsection{Entire generated code}

For the resulting file to be directly compilable, we include headers, defines, imports, etc. The resulting output file for the cooking service is:

\begin{lstlisting}
-module(proper_output).

-include_lib("proper/include/proper.hrl").
-include("proper_output.hrl").

-define(PREFIX, "properns").
-define(WSDL_URL, "http://www.webservicex.net/ConvertCooking.asmx?WSDL").

-export([call_ChangeCookingUnit/1, call_ChangeCookingUnit/2]).
-export([answer_ChangeCookingUnit/1]).

generate_ChangeCookingUnit_1_CookingValue() ->
  ?LET(Gen, float(), float_to_list(Gen)).

generate_ChangeCookingUnit_1_fromCookingUnit_Cookings() ->
  elements(["drop","dash","pinch","milliliterPerCC","deciliter",
  "coffeeSpoon", "fluidDram","teaspoonUS","teaspoonUK","tablespoonUS",
  "tablespoonUK", "fluidOunceUS","fluidOunceUK","cupUS","cubicInch",
  "gillUS","gillUK","pintUS","pintUK","quartUS","liter","gallonUS",
  "gallonUK","TwoPointFiveCan","TenCan"]).

generate_ChangeCookingUnit_1_toCookingUnit_Cookings() ->
  elements(["drop","dash","pinch","milliliterPerCC","deciliter",
  "coffeeSpoon", "fluidDram","teaspoonUS","teaspoonUK","tablespoonUS",
  "tablespoonUK", "fluidOunceUS","fluidOunceUK","cupUS","cubicInch",
  "gillUS","gillUK","pintUS","pintUK","quartUS","liter","gallonUS",
  "gallonUK","TwoPointFiveCan","TenCan"]).

generate_ChangeCookingUnit_1() ->
  ?LET(
    {Pr_ChangeCookingUnit_1_CookingValue,
     Pr_ChangeCookingUnit_1_fromCookingUnit_Cookings,
     Pr_ChangeCookingUnit_1_toCookingUnit_Cookings},
    {generate_ChangeCookingUnit_1_CookingValue(),    
     generate_ChangeCookingUnit_1_fromCookingUnit_Cookings(),
     generate_ChangeCookingUnit_1_toCookingUnit_Cookings()},
    [Pr_ChangeCookingUnit_1_CookingValue,
     Pr_ChangeCookingUnit_1_fromCookingUnit_Cookings, 
     Pr_ChangeCookingUnit_1_toCookingUnit_Cookings]
  ).

call_ChangeCookingUnit(Arguments) ->
  inets:start(),
  Wsdl = yaws_soap_lib:initModel(?WSDL_URL),
  yaws_soap_lib:call(Wsdl, "ChangeCookingUnit", Arguments).

call_ChangeCookingUnit(WSDL, Arguments) ->
  yaws_soap_lib:call(WSDL, "ChangeCookingUnit", Arguments).

prop_ChangeCookingUnit_responds() ->
  ?FORALL(Args, generate_ChangeCookingUnit_1(),
    begin
      Result = call_ChangeCookingUnit(Args),
      case Result of
	{ok, _Attribs, [Result_record]} 
	    when is_record(Result_record, 'soap:Fault') -> false;
        {ok, _Attribs, _Result_record} -> true;
        _ -> false
      end
    end).

answer_ChangeCookingUnit({ok, _, [Answer_record]}) -> Answer_record.

% ---------- End of Auto Generated Code ---------- 
\end{lstlisting}

In addition to the headers, the only other thing created by the extension is a function called "answer\_ChangeCookingUnit" which shows how to extract the Answer (record) that is returned by yaws.

Finally, the extension also uses erlsom to output a .hrl file that describes the records used for the responses of the Service. In our case:

\begin{lstlisting}
-record('properns:ChangeCookingUnit', 
	{anyAttribs, 'CookingValue', 'fromCookingUnit', 'toCookingUnit'}).
-record('properns:ChangeCookingUnitResponse', 
	{anyAttribs, 'ChangeCookingUnitResult'}).
-record('properns:double', {anyAttribs, 'double'}).
-record('soap:Body', {anyAttribs, choice}).
-record('soap:Envelope', {anyAttribs, 'Header', 'Body', choice}).    
-record('soap:Fault', {anyAttribs, 'faultcode', 'faultstring', 'faultactor', 'detail'}).  
-record('soap:Header', {anyAttribs, choice}).
-record('soap:detail', {anyAttribs, choice}).
\end{lstlisting}

We will see how these can be used in later sections.

\section{Response Testing of Web Services}

(? Den ekana akoma to change gia na kanei compile apeftheias ston kwdika gia response testing ?)

The first kind of testing, that works without any user additions is response testing. Basically, the output file created by the extension contains a property that invokes an operation of the web service with random inputs and expects an answer for each different input. This can basically check if a web service crashes for a specific input or similar unwanted behaviors. 

Let's see how to use the extension on the cooking service:

\begin{lstlisting}
Erlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] 
[async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9  (abort with ^G)
1> wsdl_handler:generate("http://www.webservicex.net/
ConvertCooking.asmx?WSDL").
ok
2> c(proper_output).
{ok,proper_output}
3> proper:quickcheck(
        proper_output:prop_ChangeCookingUnit_responds()).
....(100 dots) .....
OK: Passed 100 test(s).
true
\end{lstlisting}

As we can see, the Cooking web service was invoked 100 times with random arguments and returned a correctly formed result each time.

Now for an example of a service that crashes, we created our own web service using eclipse and tomcat. This example will also be used later on and is based on the first PropEr publication by Manos Papadakis, about a faulty delete function.

We have a simple Java implementation of the web service:

\begin{lstlisting}
public Class Delete {
    private String delete(String in, char c, StringBuffer acc){
        if (in.equals("")) {
            return acc.toString();
        }
        else if (in.charAt(0) == c) {
            return acc.toString().concat(in.substring(1));
        }
        else {
            return delete(in.substring(1), c, acc.append(in.charAt(0)));
        }
    }
    
    public String delete(String in, String c){
        return delete(in, c.charAt(0), new StringBuffer(""));
    } 
}
\end{lstlisting}

We used this code to implement and publish a simple web service in tomcat. After using the PropEr extension to handle the WSDL specification of this web service, the output file was the following:

(?Den dokimasa akoma to ascii\_list gia na to valw ki edw, opou vector(Len, integer(32,127)) theoroume string ?)

\begin{lstlisting}
-module(proper_output).

-include_lib("proper/include/proper.hrl").
-include("proper_output.hrl").

-define(PREFIX, "properns").
-define(WSDL_URL, "http://localhost:8080/
    DeleteProject/services/Delete?WSDL").

-export([call_delete/1, call_delete/2]).
-export([answer_delete/1]).

generate_delete_1_in() -> 
	?LET(
		Len, 
		range(0,inf), 
		vector(Len, integer(32,127))
	).

generate_delete_1_c() -> 
	?LET(
		Len, 
		range(0,inf), 
		vector(Len, integer(32,127))
	).

generate_delete_1() -> 
	?LET(
		{Pr_delete_1_in, Pr_delete_1_c},
		{generate_delete_1_in(), generate_delete_1_c()},
		[Pr_delete_1_in, Pr_delete_1_c]
	).

call_delete(Arguments) ->
  inets:start(),
  Wsdl = yaws_soap_lib:initModel(?WSDL_URL),
  yaws_soap_lib:call(Wsdl, "delete", Arguments).
    
call_delete(WSDL, Arguments) ->
  yaws_soap_lib:call(WSDL, "delete", Arguments).

prop_delete_responds() ->
  ?FORALL(Args, generate_delete_1(),
    begin
      Result = call_delete(Args),
      case Result of 
        {ok, _Attribs, [Result_record]} 
             when is_record(Result_record, 'soap:Fault') -> false;
        {ok, _Attribs, _Result_record} -> true;
        _ -> false
      end
    end).

answer_delete({ok, _, [Answer_record]}) -> Answer_record.

% ---------- End of Auto Generated Code ---------- 
\end{lstlisting}

Calling quickcheck with this property reveals a flaw in our implementation.
\begin{lstlisting}
> proper:quickcheck(proper_output:prop_delete_responds()). 
.!
Failed: After 2 test(s).
[[46],[]]

Shrinking .(1 time(s))
[[],[]]
false
\end{lstlisting}

In our implementation we assume that the string c which is supposed to contain at its first character the character that should be removed from the string, is not empty. We have two choices to fix it, either fix our implementation, or remove this testcase from the generator. To show how easy it is to change the generators created by the extension we choose the latter: we change the generator of c to:

\begin{lstlisting}
generate_delete_1_c() ->
  ?LET(Len, range(1,1), vector(Len, integer(32,127))).
\end{lstlisting}
We could change it to range(1,inf) or actually remove the ?LET macro, but we'd have to be carefull not to actually change the output of the generator to a char instead of a non-empty char list.

Now only valid testcases are created. Testing the response property again we get:
\begin{lstlisting}
> proper:quickcheck(proper_output:prop_delete_responds()).
....(100 dots) .....
OK: Passed 100 test(s).
true
\end{lstlisting}

\section{Property-based Testing of RESTful Web Services}

Restful web services are web services compliant to a few constraints, the main one having to do with state: Each request from any client must contain all the information needed by the service to handle the request. This makes property-based testing of these services relatively easy, since each test is self-contained and does not affect the outcome of other tests. 

Let's see the delete example in more depth now. 

The answer\_result function shows how to extract the Answer record from the call response. This response is in the form of an erlsom-created record, described in the .hrl file created by the wsdl\_handler. In the .hrl file we see a record: 
\begin{lstlisting}
-record('p:deleteResponse', {anyAttribs, 'deleteReturn'}).
\end{lstlisting}

This record is the record that contains the result (when there is no error).In the automatically generated code we can locate this function:

\begin{lstlisting}
answer_delete({ok, _, [Answer_record]}) -> Answer_record.
\end{lstlisting}

We see that the 'delete response' is a record containing a 'deleteReturn' value. This 'deleteReturn' value is the boolean we seek; therefore we change the answer function to:

\begin{lstlisting}
answer_delete({ok, _, [Answer_record]}) ->
  Answer_record#'p:deleteResponse'.'deleteReturn'.
\end{lstlisting}

Finally we write our property in a similar form to the respond property:

\begin{lstlisting}
prop_delete_removes_every_x() ->
  ?FORALL([_In, [C]]=Args, generate_delete_1(),
    begin
      R1 = call_delete(Args),
      Result = answer_delete(R1),
      not lists:member(C, Result)
  end).
\end{lstlisting}

Now checking this property with proper yields the following results:
\begin{lstlisting}
> proper:quickcheck(proper_output:prop_delete_removes_every_x()).
.......................!
Failed: After 24 test(s).
[[92,62,59,97,51,79,76,86,96,75,38,76,51,57,125,37,121,53,57,66,
67,36,96,89,100,58,38,85,88,121,65,101,106,46,58,32,123,60,
117,34,106,42,110,127,40,51,75,124,34,94,115,76],[57]]

Shrinking ................................(32 time(s))
[[32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
32,32,32,32,32,32,32,33,32,32],[32]]
false
\end{lstlisting}

We see that we find after a while a counter-example, however the shrink does not work exactly as the non-web service case. This is mostly because of the different generators used to create these arguments, since the shrinking is now handled differently.

(? Afou to parapanw ginei ascii list logika tha allaksei kai to shrinking behavior tou, twra ofeiletai sto oti to me to ?LET wraper dn kanei shrink parapanw ?)

Now we show another example of testing a RestFul Web Service, to show some limitations of our implementation. Going back to the Cooking service, a simple property that should be valid in it would be if we convert something and then convert the answer back we should get the initial number.

Let's change the answer function and write this property on the output file of the extension:

\begin{lstlisting}
answer_ChangeCookingUnit({ok, _, [Answer_record]}) -> 
  Answer_record#'p:ChangeCookingUnitResponse'.'ChangeCookingUnitResult'.

prop_back_and_forth_is_equal() ->
  ?FORALL([Value, From, To] = Args, generate_ChangeCookingUnit_1(),
    begin
      Result = call_ChangeCookingUnit(Args),
      Conv_val = answer_ChangeCookingUnit(Result),
      Result2 = call_ChangeCookingUnit([Conv_val, To, From]),
      Initial = answer_ChangeCookingUnit(Result2),
      Value == Initial
    end).
\end{lstlisting}

Basically, we break down the arguments to the sub-elements, invoke the web service, reinvoke the web service with the answer and the other two arguments flipped and compare the result. 

Testing this property we receive a (not unexpected) failure:

\begin{lstlisting}
> proper:quickcheck(proper_output:prop_back_and_forth_is_equal(), 5).
!
Failed: After 1 test(s).
[[45,49,46,54,50,55,56,54,56,51,51,53,48,55,51,56,50,48,55,50,54,57,52,101,45,48,49],[103,97,108,108,111,110,85,75],[116,97,98,108,101,115,112,111,111,110,85,83]]

Shrinking ...(3 time(s))
[[48,46,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,101,43,48,48],[100,114,111,112],[100,114,111,112]]
false
\end{lstlisting}

Basically, it fails to produce the same result even if there is no change! A closer look with a few io:formats will reveal the problem : Floating point arithmetic. The floating point numbers created as arguments by proper are converted to Strings with some error in accuracy and the 2 subsequent calls include even more arithmetical errors. If we change the equality check to a small difference check (keeping in mind that erlsom represented those numbers as strings) we change the property to:

\begin{lstlisting}
prop_back_and_forth_is_equal() ->
  ?FORALL([Value, From, To] = Args, generate_ChangeCookingUnit_1(),
    begin
      Result = call_ChangeCookingUnit(Args),
      Conv_val = answer_ChangeCookingUnit(Result),
      Result2 = call_ChangeCookingUnit([Conv_val, To, From]),
      Initial = answer_ChangeCookingUnit(Result2),
      F1 = list_to_float(Value),
      F2 = list_to_float(Initial),
      abs(F1 - F2) < 0.000001
    end).
\end{lstlisting}

And checking the property now:

\begin{lstlisting}
8> c(proper_output).                                                  
{ok,proper_output}
9> proper:quickcheck(proper_output:prop_back_and_forth_is_equal()).
......( 100 dots) .....
OK: Passed 100 test(s).
true
\end{lstlisting}

\section{Related Work}
Move this after Introduction??

Here we will refer to tools like monadWS~\cite{monadWS@AST-11} and
many other such great works...

\section{Concluding Remarks}

\bibliographystyle{eptcs}
\bibliography{ws}

\end{document}
